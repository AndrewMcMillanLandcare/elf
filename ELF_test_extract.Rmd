---
title: "R Notebook"
output: html_notebook
editor_options: 
  chunk_output_type: console
---




# Glossary

CLTL = Cieraard Latitude Treeline
LCDB = MWLR's Land Cover Database


# Libraries and folders


```{r}


library(tidyverse)
library(rjson)
library(sf)
library(mapview)
library(terra)
library(tictoc)
source("D:/HerronK/ELF_Project/AndrewsWork/MyCode/R/elf/ea_utils.R")

#set up the data folders
rdn = "D:/HerronK/ELF_Project/"

CLTL_rdn = paste0(rdn, "ELFData/Cieraad/")
AL_dn = paste0(rdn,"AndrewsWork/layers/")
NTL_dn = paste0(AL_dn,"New-Treeline-Layers/")


TL_classes_unfilt = c(14,15,16,43,55)


```


# Function: create_rect 

```{r}

create_rect = function(SP, len, wid, PHI){
  
  x1 = SP[1]
  y1 = SP[2]
  
  
  x2 = x1 + len * cos(PHI)
  y2 = y1 + len * sin(PHI)
  
  dx = x2 - x1
  dy = y2 - y1
  
  r = sqrt(dx**2 + dy**2)
  p = atan2(dy, dx)
  
  
  v1_x = x1 + (0.5*wid) * cos(p - pi/2) 
  v2_x = x1 + (0.5*wid) * cos(p + pi/2) 
  v3_x = x2 + (0.5*wid) * cos(p - pi/2) 
  v4_x = x2 + (0.5*wid) * cos(p + pi/2) 
  
  v1_y = (y1 + (0.5*wid) * sin(p - pi/2))*-1 
  v2_y = (y1 + (0.5*wid) * sin(p + pi/2))*-1
  v3_y = (y2 + (0.5*wid) * sin(p - pi/2))*-1
  v4_y = (y2 + (0.5*wid) * sin(p + pi/2))*-1
  
  
  points_x = c(v1_x, v2_x, v4_x, v3_x, v1_x)
  points_y = -1*(c(v1_y, v2_y, v4_y, v3_y, v1_y))
  
  rect = data.frame(X =points_x , Y = points_y) %>% 
    sf::st_as_sf(coords = c("X","Y")) %>% 
    sf::st_set_crs(2193) %>% 
    summarise(geometry = st_combine(geometry)) %>%
    st_cast("POLYGON")
  
  
  MV = mapview(rect)
  
  OUT = list(rect, MV, points_x, points_y)
  
  
}

```



```{r}



```


# Step 1. get the CLTL

```{r Step 1}

#set up the data folders
rdn = "D:/HerronK/ELF_Project/"
CLTL_rdn = paste0(rdn, "ELFData/Cieraad/")
AL_dn = paste0(rdn,"AndrewsWork/layers/")

#read the Cieraad Treeline based on the original regression
CLTL_ffn = paste0(CLTL_rdn,"Vector-TL-Cieraad/out.shp")
CLTL = st_read(CLTL_ffn)

#read the Cieraad Treeline based on the original regression adjusted by 100m for the NI
CLTL_NI_100m_ffn = paste0(CLTL_rdn,"NI_100m_vector_Cieraad/out.shp")
CLTL_NI_100m = st_read(CLTL_NI_100m_ffn) %>% 
  mutate(Island = "NI")

#read a polygon for the North Island
NI_poly_ffn = paste0(AL_dn,"NI.gpkg")
NI_poly = st_read(NI_poly_ffn)

#read a polygon for the North Island
SI_poly_ffn = paste0(AL_dn,"SI.gpkg")
SI_poly = st_read(SI_poly_ffn)

#grab the original tree line for the SI only
CLTL_SI =st_intersection(CLTL, SI_poly) %>% 
  mutate(Island = "SI") %>% 
  select(DN, Island)

# mapview(SI_poly)
# mapview(CLTL)
# mapview(CLTL_SI)

#combine it with the adjusted treeline for the North Is
CLTL_adj = CLTL_SI %>% bind_rows(CLTL_NI_100m)
mapview(CLTL_adj)

#save the combined/NI-Adjusted tree line
CLTL_adj_ffn = paste0(AL_dn,"CLTL_adj.gpkg")
st_write(CLTL_adj, CLTL_adj_ffn, append = F)
st_read(CLTL_adj_ffn)

```



#  Step 2. Now intersect the CLTL_adj with LCDB

```{r}

LCDB5_ffn = "D:/HerronK/ELF_Project/ELFData/LCDB/lcdb-v50-land-cover-database-version-50-mainland-new-zealand.gpkg"
LCDB5 = st_read(LCDB5_ffn)

CLTL_adj_ffn = paste0(AL_dn,"CLTL_adj.gpkg")
CLTL_adj = st_read(CLTL_adj_ffn)

tic("Intersecting LCDB5 and CLTL_adj")
LCDBxCLTL_adj = ea_intersection(LCDB5, CLTL_adj, PC = "PNGeo04-W10", "LCDBxCLTL_adj", dn = AL_dn, val = "none", parallel = T, ncore = 7, filetype = "GPKG", diff_opt = F, simplify_opt = F, tol = NULL)
toc()


LCDBxCLTL_adj_ffn = paste0(AL_dn, "LCDBxCLTL_adj.gpkg")
st_write(LCDBxCLTL_adj, LCDBxCLTL_adj_ffn, append = F)  

```

#  Step 3. Get diff between clipped features and LCDB features that intersect with CLTL

```{r}


#Define the full set of treeline classes



if (!exists("LCDBxCLTL_adj")){
  LCDBxCLTL_adj_ffn = paste0(AL_dn, "LCDBxCLTL_adj.gpkg")
  LCDBxCLTL_adj = st_read(LCDBxCLTL_adj_ffn)  
}

if (!exists("LCDB5")){
  LCDB5_ffn = "D:/HerronK/ELF_Project/ELFData/LCDB/lcdb-v50-land-cover-database-version-50-mainland-new-zealand.gpkg"
  LCDB5 = st_read(LCDB5_ffn)
  
}

# get the LCDB features that intersect with the CTLT
intersecting_features = LCDBxCLTL_adj %>% pull(LCDB_UID) %>% unique()
LCDB5_intersecting_feat = LCDB5 %>% 
  filter(LCDB_UID %in% intersecting_features & Class_2018 %in% TL_classes_unfilt)

mapview(LCDB5_intersecting_feat)

# now create a layer of the split features that lie outside of the CLTL (takes 7 minutes sec)
tic("Getting difference between LCDB5_intersecting_feat and LCDBxCLTL_adj")
LCDB5_intersecting_feat_minus_LCDBxCLTL_adj = getLayerDiff(LCDB5_intersecting_feat, LCDBxCLTL_adj)
toc()

#add in the island information

island_key = LCDBxCLTL_adj %>% 
  st_set_geometry(NULL) %>% 
  select(LCDB_UID, Island) %>% 
  distinct() %>% 
  as_tibble()

LCDB5_intersecting_feat_minus_LCDBxCLTL_adj = LCDB5_intersecting_feat_minus_LCDBxCLTL_adj %>% 
  left_join(island_key, by = "LCDB_UID")


LCDB5_intersecting_feat_minus_LCDBxCLTL_adj_ffn = paste0(AL_dn, "New-Treeline-Layers/LCDB5_intersecting_feat_minus_LCDBxCLTL_adj.gpkg")
st_write(LCDB5_intersecting_feat_minus_LCDBxCLTL_adj, LCDB5_intersecting_feat_minus_LCDBxCLTL_adj_ffn,append = F)



```

#  Step 4. extract DEM zonal stats from outside treeline class polys

```{r}

library(exactextractr)
# 
# # load the layer
# if (!exists("LCDBxCLTL_adj")){
#   LCDBxCLTL_adj_ffn = paste0(AL_dn, "LCDBxCLTL_adj.gpkg")
#   LCDBxCLTL_adj = st_read(LCDBxCLTL_adj_ffn)  
# }

LCDB5_intersecting_feat_minus_LCDBxCLTL_adj_ffn = paste0(AL_dn, "New-Treeline-Layers/LCDB5_intersecting_feat_minus_LCDBxCLTL_adj.gpkg")
LCDB5_intersecting_feat_minus_LCDBxCLTL_adj = st_read(LCDB5_intersecting_feat_minus_LCDBxCLTL_adj_ffn)

outside_polys = LCDB5_intersecting_feat_minus_LCDBxCLTL_adj

# grab the dem

dem_ffn = "D:/HerronK/ELF_Project/ELFData/NZ_DEM/dem_linz_nz_110520_orthonzgd49h_nztm_10m.kea"
dem = rast(dem_ffn)

# extract zonal stats from the DEM

outside_polys$alt_stats = exactextractr::exact_extract(dem, outside_polys, c("min", "mean"))

outside_polys_w_ZSTATS = outside_polys %>% 
  mutate(min_alt = alt_stats$min, mean_alt = alt_stats$mean) %>% 
  select(-contains("stats"))



names(LCDBxCLTL_adj)  
names(outside_polys_w_ZSTATS)  
# save the data with the Zonal Stats

# LCDBxCLTL_adj_w_ZSTATS_ffn = paste0(AL_dn, "LCDBxCLTL_adj_w_ZSTATS_v02.gpkg")
# st_write(LCDBxCLTL_adj_w_ZSTATS, LCDBxCLTL_adj_w_ZSTATS_ffn, append = F)


outside_polys_w_ZSTATS_ffn = paste0(AL_dn, "outside_polys_w_ZSTATS.gpkg")
st_write(outside_polys_w_ZSTATS, outside_polys_w_ZSTATS_ffn, append = F)

names(outside_polys_w_ZSTATS)

```


#  Step 5. Filter the outside_polys

apply the rules set out in Section 3.2ii of Caitlin's Report

```{r}

outside_polys_w_ZSTATS_ffn = paste0(AL_dn, "outside_polys_w_ZSTATS.gpkg")
outside_polys_w_ZSTATS = st_read(outside_polys_w_ZSTATS_ffn)


#Class 16 (Gravel and Rock) Rules
# 1. Any Class 16 Features that lie fully or mostly within layer are kept
# 2. Any Class 16 Features that intersect with layer but are mostly outside CLTL
# 1. Any Class 16 Features that lie within layer are kept

# #check that LCDB_UID is indeed a unique ID --> CONFIRMED
# (LCDB5 %>% pull(LCDB_UID) %>% unique() %>% length()) == LCDB5 %>% nrow()
# 
# #get the original areas of each polygon from LCDB
# LCDB5_orig_areas = LCDB5 %>% 
#   mutate(ORIG_AREA_ha = as.numeric(st_area(.))/1e4) %>% 
#   st_set_geometry(NULL) %>% 
#   select(LCDB_UID, ORIG_AREA_ha)


#for all the intersecting polygons add the orginal area
outside_polys_w_ZSTATS_mdf = 
  outside_polys_w_ZSTATS %>% mutate(AREA_ha = as.numeric(st_area(.))/1e4) 



#create flags:
# TREELINE_CLASS_FLAG: if class is 14,15,43,55
# CLASS 14: Permanent Snow and Ice
# CLASS 15: Alpine grass / herbfield
# CLASS_16: if class is 16 (gravel and rock)
# CLASS_43_OR_55_FLAG (43 = Tall Tussuck, 55 = Sub-Alpine Scrubland)
# CLASS_43_OR_55_GOOD_ALT ()

FRAC_INSIDE_THRESH = 0.5

#Apply the Filtering Logic on P3-4 of ETL report

outside_polys_flagged = outside_polys_w_ZSTATS_mdf %>% 
  #flag the class 16 data that mostly lie outside CLTL
  mutate(
    TREELINE_CLASS_FLAG = ifelse(Class_2018 %in% TL_classes_unfilt, TRUE, FALSE),
    KEEP_FLAG = case_when(
      # Not a treeline class -> Reject
      !TREELINE_CLASS_FLAG ~ "REJECT",
      # Class 14 and 15 are automatically kept
      Class_2018 == 14 | Class_2018 == 15 ~ "KEEP",
      # Class 16 features mostly outside and original area is > 10 ha need to be checked
      (Class_2018 == 16) & (AREA_ha >= 10)  ~ "CHECK",
      (Class_2018 == 16) & (AREA_ha < 10)  ~ "KEEP",
      # (Class_2018 != 16) & (FRAC_INSIDE >= FRAC_INSIDE_THRESH) ~ "N/A",
      # Class 43 and 55
      (Class_2018 == 43 | Class_2018 == 55) & (Island == "NI") & (min_alt > 900 | mean_alt > 1200) ~ "KEEP",
      (Class_2018 == 43 | Class_2018 == 55) & (Island == "NI") & (min_alt <= 900 & mean_alt <= 1200) ~ "CHECK",
      (Class_2018 == 43 | Class_2018 == 55) & (Island == "SI") &  (mean_alt > 1300) ~ "KEEP",
      (Class_2018 == 43 | Class_2018 == 55) & (Island == "SI") &   mean_alt > 1200 & min_alt > 400 ~ "KEEP",
      (Class_2018 == 43 | Class_2018 == 55) & (Island == "SI") &  (mean_alt <= 1200 | min_alt <= 400) ~ "CHECK",
      (Class_2018 == 43 | Class_2018 == 55) & (Island == "SI") &  (mean_alt < 1300 & (!(mean_alt > 1200 & min_alt > 400))) ~ "CHECK"))

outside_polys_flagged_ffn = paste0(AL_dn,"New-Treeline-Layers/outside_polys_flagged.gpkg")
st_write(outside_polys_flagged, outside_polys_flagged_ffn, append = F)


#How many require checking?

outside_polys_flagged %>% nrow() #17408
outside_polys_flagged %>% filter(KEEP_FLAG == "KEEP") %>% nrow() #6722
outside_polys_flagged %>% filter(KEEP_FLAG == "CHECK") %>% nrow() #10686
outside_polys_flagged %>% filter(KEEP_FLAG == "CHECK" | KEEP_FLAG == "KEEP") %>% nrow() #17408
outside_polys_flagged %>% filter(KEEP_FLAG == "REJECT") %>% nrow()  # 0


#of the checked polys what are the classes

outside_polys_flagged %>% 
  st_set_geometry(NULL) %>% 
  as_tibble() %>% 
  filter(KEEP_FLAG == "CHECK") %>% 
  group_by(Class_2018) %>% 
  summarise(
    Num = length(Class_2018),
    Area_avg = mean(AREA_ha),
    mean_alt_avg = mean(mean_alt),
    mean_alt_sd = sd(mean_alt),
    mean_alt_ln = length(mean_alt),
    mean_alt_min = min(mean_alt),
    mean_alt_max = max(mean_alt),
    mean_alt_med = median(mean_alt))




```

#  Step 6. Grab the Clipped Layer and then combine it with the filtered outsidepolys


```{r}
outside_polys_flagged_ffn = paste0(AL_dn,"New-Treeline-Layers/outside_polys_flagged.gpkg")
outside_polys_flagged = st_read(outside_polys_flagged_ffn)

LCDBxCLTL_adj_ffn = paste0(AL_dn, "LCDBxCLTL_adj.gpkg")
LCDBxCLTL_adj = st_read(LCDBxCLTL_adj_ffn)  

#Temporary - for now - keep only those flagged with keep

outside_polys_filtered = outside_polys_flagged %>% 
  filter(KEEP_FLAG == "KEEP")


outside_polys_filtered_UNN_ffn = paste0(NTL_dn, "outside_polys_filtered_UNN.gpkg")
st_write(outside_polys_filtered_UNN, outside_polys_filtered_UNN_ffn, append = F)

outside_polys_filtered_UNN_ffn = paste0(NTL_dn, "outside_polys_filtered_UNN.gpkg")
st_write(outside_polys_filtered_UNN, outside_polys_filtered_UNN_ffn, append = F)


inside_polys_filtered_UNN = LCDBxCLTL_adj %>% 
  filter(Class_2018 %in% TL_classes_unfilt) %>% 
  validate_sh() %>% 
  group_by(LCDB_UID) %>% 
  st_union(by_feature = T)

inside_polys_filtered_UNN_ffn = paste0(NTL_dn, "inside_polys_filtered_UNN.gpkg")
st_write(inside_polys_filtered_UNN, inside_polys_filtered_UNN_ffn, append = F)



#-----------------------testing how to do spatial join by field -----#
# define a test area

TB = st_read(paste0(AL_dn, "testbox2.shp"))

outside_polys_filtered_UNN_clip = st_intersection(outside_polys_filtered_UNN, TB)
inside_polys_filtered_UNN_clip = st_intersection(inside_polys_filtered_UNN, TB)




all_polys_filtered_UNN_clip = outside_polys_filtered_UNN_clip %>% 
  bind_rows(inside_polys_filtered_UNN_clip) %>% 
  group_by(LCDB_UID) %>% 
  summarise(LCDB_UID_first = first(LCDB_UID))

C = mapview(all_polys_filtered_UNN_clip)

outside_polys_filtered_UNN_clip$mean_alt

A = mapview(outside_polys_filtered_UNN_clip)
B = mapview(inside_polys_filtered_UNN_clip, col.region = "pink")

B + A

#------------- end of test ---------#


# combine the polys in and out then spatially join the polys with the same UID
# this takes about 10 minutes. You also lose all the data except for the geometry
# we get 35619 features

tic()
all_polys_filtered = inside_polys_filtered_UNN %>% 
  bind_rows(outside_polys_filtered_UNN) %>% 
  group_by(LCDB_UID) %>% 
  summarise(LCDB_UID_first = first(LCDB_UID))
toc()

#write this new layer to disk
all_polys_filtered_ffn = paste0(NTL_dn, "all_polys_filtered.gpkg")
st_write(all_polys_filtered, all_polys_filtered_ffn)

#grab the original attributes from LCDB
LCDBxCLTL_adj_nogeo = LCDBxCLTL_adj %>% 
  st_set_geometry(NULL) %>% 
  as_tibble()

#join in the attributes
all_polys_filtered_mdf = all_polys_filtered %>% 
  left_join(LCDBxCLTL_adj_nogeo, by = "LCDB_UID")

#combine treeline layer into a single polygon
all_polys_unioned = st_parallel(all_polys_filtered_mdf, st_union)


all_polys_unioned_ffn = paste0(NTL_dn, "all_polys_unioned.gpkg")
st_write(all_polys_unioned, all_polys_unioned_ffn, append = F)


# call this the improved tree line as well 

improved_treeline_poly = all_polys_unioned

improved_treeline_poly_ffn = paste0(NTL_dn, "improved_treeline_poly.gpkg")
st_write(improved_treeline_poly, improved_treeline_poly_ffn, append = F)

improved_treeline_lines = improved_treeline_poly %>% 
  st_cast("POLYGON") %>% 
  st_cast("MULTILINESTRING")

improved_treeline_lines_ffn = paste0(NTL_dn, "improved_treeline_lines.gpkg")
st_write(improved_treeline_lines, improved_treeline_lines_ffn, append = F)




```



# Step 7. Create a sampling grid and intersect it 

```{r}

SAMPLING_INTERVAL_km = 20

PL = create_parallel_lines(LL = c(1000000, 4700000), UR = c(2100000, 6200000), x_interv = SAMPLING_INTERVAL_km*1000, y_interv=SAMPLING_INTERVAL_km*1000, direction = "H")

mapview(PL)

samp_points = st_intersection(RESULT_lines, PL)

A = mapview(RESULT_lines, color="green")
B = mapview(PL, coloor="blue")
C = mapview(samp_points, color = "red")




A + B + C

PL_ffn = paste0(NTL_dn, "PL.gpkg")
st_write(PL, PL_ffn, append = F)

samp_points_ffn = paste0(NTL_dn, "samp_points.shp")
st_write(samp_points %>% st_cast("MULTIPOINT"), samp_points_ffn, append = F)

# samp_points_ffn = paste0(NTL_dn, "samp_points.gpkg")
# st_write(samp_points, samp_points_ffn, append = F)
```

# Step 8 OLD. Take a point and make a sampling rectange 

```{r}
Y = 5477617
X = 1798886

df = data.frame(X,Y)
d_sf = st_as_sf(df, coords = c("X","Y"),crs = 2193)

mapview(d_sf)

# extract_coords back out of sf

SP = st_coordinates(d_sf)

LEN = 500
WID = 20
PHI = 60 * pi/180

RECT = create_rect(SP, LEN, WID, PHI)

RECT_shp = RECT[[1]]

```


# Step 8. Take a point and make sampling rectangles of all different angles. Find which angle is the steepest

```{r}
Y = 5477617
X = 1798886

df = data.frame(X,Y)
d_sf = st_as_sf(df, coords = c("X","Y"),crs = 2193)

mapview(d_sf)

# extract_coords back out of sf

SP = st_coordinates(d_sf)

LEN = 500
WID = 20

DIV_deg = 30
PHI_deg_seq = seq(DIV_deg,360,DIV_deg)

tb = data.frame(PHI_deg = PHI_deg_seq ) %>% 
  mutate(
    PHI = PHI_deg * pi/180,
    SLOPE_m = NA,
    SLOPE_c = NA,
    SLOPE_r2 = NA,
  )


for (iPHI in 1:length(PHI_deg_seq)){
  
  # iPHI=7
  
  print(paste("Processing angle", iPHI,"of",length(PHI_deg_seq) ))
  
  c_PHI_deg = PHI_deg_seq[iPHI]
  PHI = c_PHI_deg * pi/180
  
  RECT = create_rect(SP, LEN, WID, PHI)
  RECT_shp = RECT[[1]]
  DTM_cropped = crop(DTM, extent(RECT_shp))
  DTM_cropped_masked = mask(DTM_cropped, RECT_shp)
  ZVALS = DTM_cropped_masked@data@values
  ncells = DTM_cropped_masked@ncols*DTM_cropped_masked@nrows
  CELLS = 1:ncells
  
  XY = t(sapply(CELLS, function(x) {xyFromCell(DTM_cropped_masked,x)} )) %>% 
    as.data.frame() %>% 
    as_tibble() %>% 
    mutate(Z = ZVALS)
  
  names(XY) <- c("X","Y","Z")
  
  X_cent = SP[1]
  Y_cent = SP[2]
  
  
  XY_dist = XY %>% 
    mutate(
      DX = X - X_cent,
      DY = Y - Y_cent,
      R = sqrt(DX^2+DY^2))
  
  SLOPE_REG_STATS = summary(lm(Z ~ R, data = XY_dist))
  SLOPE_REG_ICP = SLOPE_REG_STATS$coefficients[1]
  SLOPE_REG_SLP = SLOPE_REG_STATS$coefficients[2]
  SLOPE_REG_RSQ = SLOPE_REG_STATS$r.squared
  
  tb$SLOPE_m[iPHI] = SLOPE_REG_SLP
  tb$SLOPE_c[iPHI] = SLOPE_REG_ICP
  tb$SLOPE_r2[iPHI] = SLOPE_REG_RSQ
  
  
}

#find angle of the most negative slope
PHI_STEEPEST = tb$PHI[which.min(tb$SLOPE_m)]



```


#step 9 . Use rectangle to sample lidar DEM data

```{r}

RECT = create_rect(SP, 500, 50, PHI_STEEPEST)
RECT_shp = RECT[[1]]

DTM = raster(lidar_dtm_ffn) 
DTM_cropped = crop(DTM, extent(RECT_shp))
DTM_cropped_masked = mask(DTM_cropped, RECT_shp)

CHM = raster(lidar_chm_ffn) 
CHM_cropped = crop(CHM, extent(RECT_shp))
CHM_cropped_masked = mask(CHM_cropped, RECT_shp)

mapview(CHM_cropped_masked)




DTM = raster(lidar_dtm_ffn) 
DTM_cropped = crop(DTM, extent(RECT_shp))
DTM_cropped_masked = mask(DTM_cropped, RECT_shp)

DTM = raster(lidar_dtm_ffn) 
DTM_cropped = crop(DTM, extent(RECT_shp))
DTM_cropped_masked = mask(DTM_cropped, RECT_shp)





```



```{r}
plot(DTM_cropped_masked)
plot(DTM_cropped)
DTM_cropped_masked@data@values


```

Function: flatten_rast 

```{r}


flatten_rast = function(RAST, PHI, XY_ORIG){
  
  RAST = DTM_cropped_masked
  ZVALS = DTM_cropped_masked@data@values
  
  ncells = RAST@ncols*DTM_cropped_masked@nrows
  CELLS = 1:ncells
  
  XY = t(sapply(CELLS, function(x) {xyFromCell(DTM_cropped_masked,x)} )) %>% 
    as.data.frame() %>% 
    as_tibble() %>% 
    mutate(Z = ZVALS)
  
  names(XY) = c("X", "Y","Z")
  
  X_cent = XY_ORIG[1]
  Y_cent = XY_ORIG[2]
  
  XY_flat = XY %>% 
    mutate(
      DX = X - X_cent,
      DY = Y - Y_cent,
      R = sqrt(DX^2+DY^2),
      OMEGA = atan2(DX,DY),
      OMEGA_ADJ = OMEGA+PHI+pi/2,
      RX = R * cos(OMEGA_ADJ)+ median(X),
      RY = R * sin(OMEGA_ADJ)+ median(Y),
      XNEW = round(RX),
      YNEW = round(RY))
  
  XYZ_flat = XY_flat %>% 
    dplyr::select(X = XNEW, Y = YNEW, Z = Z) %>% 
    filter(!is.na(Z))
  
  r_flat = rasterFromXYZ(XYZ_flat, crs = 2193)
  
}



```

# Step 10. Flatten the sampled raster so that it can be sampled

```{r}


mapview(DTM_cropped_masked)


ZVALS = DTM_cropped_masked@data@values
# ncells = DTM_cropped_masked@ncols*DTM_cropped_masked@nrows
# CELLS = 1:ncells

XY = t(sapply(CELLS, function(x) {xyFromCell(DTM_cropped_masked,x)} )) %>% 
  as.data.frame() %>% 
  as_tibble() %>% 
  mutate(Z = ZVALS)

names(XY) = c("X", "Y","Z")


X_cent = median(XY$X)
Y_cent = median(XY$Y)

X_cent = x1
Y_cent = y1


XY_flat = XY %>% 
  mutate(
    DX = X - X_cent,
    DY = Y - Y_cent,
    R = sqrt(DX^2+DY^2),
    OMEGA = atan2(DX,DY),
    OMEGA_ADJ = OMEGA+PHI+pi/2,
    
    RX = R * cos(OMEGA_ADJ)+ median(X),
    RY = R * sin(OMEGA_ADJ)+ median(Y),
    XNEW = round(RX),
    YNEW = round(RY))


# calculate a regression between Z and R (the distance from point 1)

SLOPE_REG_STATS = summary(lm(Z ~ R, data = XY_flat))
SLOPE_REG_ICP = SLOPE_REG_STATS$coefficients[2]
SLOPE_REG_SLP = SLOPE_REG_STATS$coefficients[1]
SLOPE_REG_RSQ = SLOPE_REG_STATS$r.squared

XYZ_flat = XY_flat %>% 
  dplyr::select(X = XNEW, Y = YNEW, Z = Z) %>% 
  filter(!is.na(Z))

r_flat = rasterFromXYZ(XYZ_flat, crs = 2193)
mapview(r_flat)


data = r_flat@data@values %>% matrix(nrow=r_flat@nrows)
dim(data)

class(data)

```



```{r}
#create a circle of x m around point

RAD = 500
nincs = 50
PHI = seq(-pi , pi, 2*pi/nincs)

circle_pts_x = RAD * cos(PHI)+SP[1]
circle_pts_y = RAD * sin(PHI)+SP[2]

CIRCLE = data.frame(X = circle_pts_x, Y = circle_pts_y)
CIRCLE = bind_rows(CIRCLE, CIRCLE[1,])

ggplot(CIRCLE, aes(X,Y)) + geom_point()

CIRCLE_sf = st_as_sf(CIRCLE, coords = c("X","Y"),crs = 2193) %>% 
  summarise(geometry = st_combine(geometry)) %>%
  st_cast("POLYGON")



bbox = as.data.frame(
  t(
    matrix(c(min(CIRCLE$X),min(CIRCLE$Y),
             max(CIRCLE$X),min(CIRCLE$Y),
             max(CIRCLE$X),max(CIRCLE$Y),
             min(CIRCLE$X),max(CIRCLE$Y),
             min(CIRCLE$X),min(CIRCLE$Y)), nrow=2) ) )

names(bbox) = c("X","Y")

bbox_sf = st_as_sf(bbox, coords = c("X","Y"),crs = 2193) %>% 
  summarise(geometry = st_combine(geometry)) %>%
  st_cast("POLYGON")



A = mapview(CIRCLE_sf)
B = mapview(bbox_sf)
C = mapview(d_sf)

A+B+C


# Now fins out what LIDAR Layer this intersects with

Lidar_Index_Tiles = "D:/HerronK/ELF_Project/AndrewsWork/Lidar-Index-Tiles-LINZ/All_LINZ_LiDAR_Index_Tiles.shp"

LIT = st_read(Lidar_Index_Tiles)

ix = st_intersection(LIT, bbox_sf)
Lidar_Survey_name = unique(ix$name)

lidar_stub_list =c("gw", "hbrc", "marlborough", "Taranaki", "nt")


#try and obtain a polygon that is the boudary of the lidar data

filetbl = read_csv("D:/HerronK/ELF_Project/AndrewsWork/Lidar-Data-File-Table.csv")

lidar_chm_ffn = paste0(filetbl$REG_Folder[filetbl$REG_ABB=="MARL"], "\\",filetbl$CHM[filetbl$REG_ABB=="MARL"])
file.exists(lidar_chm_ffn)

library(stars)
library(raster)

lidar_chm_ffn = paste0(filetbl$REG_Folder[filetbl$REG_ABB=="GRWEL"], "\\",filetbl$CHM[filetbl$REG_ABB=="GRWEL"])
CHM = raster(lidar_chm_ffn) 
CHM_cropped = crop(CHM,bbox_sf ) 


MV = mapview(CHM_cropped)


tic()
lidar_dtm_ffn = paste0(filetbl$REG_Folder[filetbl$REG_ABB=="GRWEL"], "\\",filetbl$DTM[filetbl$REG_ABB=="GRWEL"])
DTM = raster(lidar_dtm_ffn) 
DTM_cropped = crop(DTM,bbox_sf ) 
mapview(DTM_cropped)
toc()

tic()
ASPECT = terrain(DTM_cropped, 'aspect', unit = 'degrees', neighbors = 8)
mapview(ASPECT)
toc()

ntints = 36
ints = seq(-pi, +pi, (2 * pi)/(36))

len = 500
wid = 20

# for (p in ints){


PHI = ints[19]

rot_angle = 180/pi*PHI
```


```{r}
# extract the DEM and work out slope

# +proj=tpeqd +lat_1=0 +lon_1=0 +lat_2=60 +lon_2=60 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs +type=crs


CRS = st_crs(rect)
str(CRS)

r2 = crop(DTM_cropped, extent(rect))
r3 = mask(r2, rect)

plot(r3)
plot(r2)
r3@data@values



# 
# 
# DTM_STRS = st_as_stars(DTM_cropped)
# 
# DTM_cropped_clip = DTM_STRS[rect]
# 
# 
# DTM_STRS = st_transform_proj(DTM_STRS, 2193)
# st_crs(DTM_STRS)
# 
# DTM_cropped_clip = DTM_STRS[rect]
# 
# plot(DTM_cropped_clip)
# 
# extent(rect)
# st_crs(rect)
# 
# st_dimensions(DTM_STRS)
# st_crs(DTM_STRS)
# st_coordinates(DTM_STRS)
# 
# str(DTM_cropped_clip)
# 
# 
# MV = MV + mapview(DTM_cropped_clip)
# MV 

DTM_cropped_clip = r3

mapview(DTM_cropped_clip)

ZVALS = DTM_cropped_clip@data@values
ncells = DTM_cropped_clip@ncols*DTM_cropped_clip@nrows
CELLS = 1:ncells

XY = t(sapply(CELLS, function(x) {xyFromCell(DTM_cropped_clip,x)} )) %>% 
  as.data.frame() %>% 
  as_tibble() %>% 
  mutate(Z = ZVALS)

names(XY) = c("X", "Y","Z")


X_cent = median(XY$X)
Y_cent = median(XY$Y)

X_cent = x2
Y_cent = y2


XY_flat = XY %>% 
  mutate(
    DX = X - X_cent,
    DY = Y - Y_cent,
    R = sqrt(DX^2+DY^2),
    OMEGA = atan2(DX,DY),
    OMEGA_ADJ = OMEGA+PHI+pi/2,
    
    RX = R * cos(OMEGA_ADJ)+ median(X),
    RY = R * sin(OMEGA_ADJ)+ median(Y),
    XNEW = round(RX),
    YNEW = round(RY))





XYZ_flat = XY_flat %>% dplyr::select(X = XNEW, Y = YNEW, Z = Z)
r_flat = rasterFromXYZ(XYZ_flat, crs = 2193)
mapview(r_flat)


data = r_flat@data@values %>% matrix(nrow=r_flat@nrows)
dim(data)


XYZ_orig = XY_flat %>% dplyr::select(X = X, Y = Y, Z = Z)
r_orig = rasterFromXYZ(XYZ_orig, crs = 2193)
mapview(r_orig)

raster::rotate(DTM_cropped_clip)


PRJ_STR = "+proj=tpeqd +lat_1=0 +lon_1=0 +lat_2=60 +lon_2=60 +x_0=0 +y_0=0 +a=6371000 +b=6371000 +units=m +no_defs "

PRJ_STR = "+proj=tpeqd +lat_1={} +lon_1={} +lat_2={} +lon_2={}  "
mapview(st_transform(rect, PRJ_STR))


WKT2_tpeqd = PROJCS["World_Two_Point_Equidistant",
                    GEOGCS["WGS 84",
                           DATUM["WGS_1984",
                                 SPHEROID["WGS 84",6378137,298.257223563,
                                          AUTHORITY["EPSG","7030"]],
                                 AUTHORITY["EPSG","6326"]],
                           PRIMEM["Greenwich",0],
                           UNIT["Degree",0.0174532925199433]],
                    PROJECTION["Two_Point_Equidistant"],
                    PARAMETER["Latitude_Of_1st_Point",0],
                    PARAMETER["Longitude_Of_1st_Point",0],
                    PARAMETER["Latitude_Of_2nd_Point",60],
                    PARAMETER["Longitude_Of_2nd_Point",60],
                    PARAMETER["false_easting",0],
                    PARAMETER["false_northing",0],
                    UNIT["metre",1,
                         AUTHORITY["EPSG","9001"]],
                    AXIS["Easting",EAST],
                    AXIS["Northing",NORTH],
                    AUTHORITY["ESRI","54031"]]


MG = meshgrid(DTM_cropped_clip)



xyFromCell(DTM_cropped_clip, )


PRJ_STR = "+proj=tpeqd +lat_1=0 +lon_1=0 +lat_2=60 +lon_2=60 +x_0=0 +y_0=0 +a=6371000 +b=6371000 +units=m +no_defs "



DTM_cropped_clip@extent
DTM_cropped_clip@ncols

DTM_cropped_clip %>% xFromCol(1)



DTM_values = matrix(data = values(DTM_cropped_clip), ncol = DTM_cropped_clip@ncols) 


library(pracma)

MG = meshgrid(1:DTM_cropped_clip@ncols, 1:DTM_cropped_clip@nrows)

PX = MG[[1]]
PY = MG[[2]]



str(DTM_cropped_clip)



CX = DTM_cropped_clip@ncols/2
CY = DTM_cropped_clip@nrows/2

DX = PX-CX
DY = PY-CY

r = sqrt(DX^2 + DY^2)
omega = atan2(DY,DX)

theta = p
omega_adj = omega + theta
RX = round(r * cos(omega_adj))
RY = round(r * sin(omega_adj))

RX = (RX - min(RX))
RY = (RY - min(RY))






PX = mapview(DTM_cropped)
B = mapview(rect, alpha.region = 0)

A + B

# }

```

```{r}

library(raster)
r1 <- brick(system.file("external/rlogo.grd", package="raster"))
r1
x <- crop(r1, extent(0,ncol(r1),0,nrow(r1)))
plotRGB(x)

x1 <- 0:ncol(x)
y1 <- 0:nrow(x)
z <- matrix(1, nrow=length(x1), ncol=length(y1))

col.mat <- t(apply(matrix(rgb(getValues(x)/255), nrow=nrow(x), byrow=TRUE), 2, rev))

# Rotate 45 degrees
persp(x1, y1, z, zlim=c(0,2), theta = 20, phi = 90, 
      col = col.mat, scale=FALSE, border=NA, box=FALSE)
png("SaveThisPlot.png")
A = persp(x1, y1, z, zlim=c(0,2), theta = 20, phi = 90, 
          col = col.mat, scale=FALSE, border=NA, box=FALSE)
dev.off()


```


```{r}

library(terra)
z <- raster(lidar_chm_ffn)
pe <- as.polygons(ext(z))
pr <- as.polygons(z > -Inf)

lregion = lidar_stub_list[1]

CHM_ffn = paste0(rdn, paste0(lidar_stub_list,"/", lidar_stub_list, "Data/", lidar_stub_list,"_CHM_1m.kea"))




CHM_ffn = paste0(rdn, paste0(lregion,"/", lregion, "Data/", lregion,"_CHM_1m.kea"))


file.exists(CHM_ffn)



names_in_tile_index = c("wellington", "not-present", 
                        
                        library(sf)
                        #> Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1
                        library(stars)
                        #> Loading required package: abind
                        library(raster)
                        #> Loading required package: sp
                        #> 
                        #> 
                        #> 
                        #> 
                        #> 
                        
                        library(terra)
                        library(raster)
                        LIDAR = rast(lidar_file)
                        
                        LIDAR_crop = crop(LIDAR, extent( bbox_sf))
                        
                        Lidar_map = raster(LIDAR_crop)
                        
                        
                        
                        ```
                        
                        
                        
                        
                        ```{r}
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        ```
                        
                        
                        
                        ```{r}
                        # New_TL_unfilt_w_FLAGS_ffn2 = paste0(AL_dn,"New-Treeline-Layers/New_TL_unfilt_w_FLAGS.shp")
                        # st_write(New_TL_unfilt_w_FLAGS, New_TL_unfilt_w_FLAGS_ffn2)
                        
                        #Save the layer to check
                        
                        New_TL_filtered_to_CHECK = New_TL_unfilt_w_FLAGS %>% 
                          filter(KEEP_FLAG == "CHECK")
                        
                        New_TL_filtered_to_CHECK_ffn = paste0(AL_dn,"New-Treeline-Layers/New_TL_filtered_to_CHECK.gpkg")
                        st_write(New_TL_filtered_to_CHECK, New_TL_filtered_to_CHECK_ffn, append = F)
                        
                        
                        #Create a new layer with just the shapes to check
                        
                        New_TL_filtered_to_CHECK
                        
                        
                        
                        
                        
                        ```
                        
                        
                        
                        #Test Extract
                        
                        ```{r}
                        
                        
                        dn = "D:/HerronK/ELF_Project/Taranaki/TaranakiProfiles/"
                        fn = "taranaki2_chmProfile.json"
                        ffn = paste0(dn,fn)
                        
                        dn = "D:/HerronK/ELF_Project/gw/gwProfiles/"
                        fn = "gw6_chmProfile.json"
                        ffn = paste0(dn,fn)
                        
                        
                        file.exists(ffn)
                        
                        prof = fromJSON(file = ffn) # %>% map_df(as_tibble)
                        prof[[1]]
                        
                        df <- data.frame(matrix(unlist(prof), ncol = max(lengths(prof))+1, byrow = TRUE)) %>% as_tibble()
                        nms = c("dist",   "coords_1", "coords_2", "Min",    "Mean",   "Median", "Max",    "Std"   )
                        
                        names(df) = nms
                        
                        
                        g = ggplot(df) + geom_line(aes(dist, Mean))
                        g
                        
                        df_mdf = df %>% 
                          mutate(
                            coords_1_diff = c(0,diff(coords_1)),
                            coords_2_diff = c(0,diff(coords_2)),
                            coords_1_diff_sq = coords_1_diff^2,
                            coords_2_diff_sq = coords_2_diff^2,
                            coords_dist = sqrt(coords_1_diff_sq + coords_2_diff_sq))
                        
                        
                        
                        
                        coords_tr = df_mdf %>% select(lat = coords_1, lon = coords_2)
                        
                        coords_sf = st_as_sf(coords_tr, coords = c("lat", "lon"), crs = 2193)
                        mapview(coords_sf)
                        
                        coords_shp_ffn =  "D:/HerronK/ELF_Project/AndrewsWork/TestTr.shp"
                        st_write(coords_sf , coords_shp_ffn)
                        
                        
                        
                        ```
                        
                        # Intersect LCDB with the Masked DEM Layer 
                        
                        ```{r}
                        
                        library(tidyverse)
                        library(sf)
                        library(mapview)
                        library(terra)
                        
                        source("D:/HerronK/ELF_Project/AndrewsWork/MyCode/R/ea_utils.R")
                        
                        LCDB5_ffn = "D:/HerronK/ELF_Project/ELFData/LCDB/lcdb-v50-land-cover-database-version-50-mainland-new-zealand.gpkg"
                        file.exists(LCDB5_ffn)
                        
                        # dem_dn = "D:/HerronK/ELF_Project/ELFData/NZ_DEM/"
                        # dem_fn = "dem_linz_nz_110520_orthonzgd49h_nztm_10m.kea"
                        # dem_ffn = paste0(dem_dn, dem_fn)
                        # dem = rast(dem_ffn)
                        # plot(dem)
                        # class(dem)
                        
                        root1 = "D:/HerronK/ELF_Project/AndrewsWork/"
                        DEM_masked = st_read(paste0(root1, "DEM_MASKED_POLY.json"))
                        
                        mapview(DEM_masked)
                        
                        
                        # A = st_intersection("")
                        
                        DIROUT = "D:/HerronK/ELF_Project/AndrewsWork/"
                        
                        DEM_maskedxLCDB = ea_intersection(LCDB5, DEM_masked, PC = "PNGeo04-W10", "Stub_", dn = DIROUT, val = "none", parallel = T, ncore = 7, filetype = "GPKG", diff_opt = F, simplify_opt = F, tol = NULL)
                        
                        
                        
                        treeline_classes_init = c(14,15,16,43,55)
                        treeline_init = LCDB5 %>% filter(Class_2018 %in% treeline_classes_init)
                        
                        mapview(treeline_init)
                        
                        CLT
                        
                        ```
                        
                        # Make a shape file of all the available LIDAR tiles
                        
                        ```{r}
                        
                        dn = "D:/HerronK/ELF_Project/AndrewsWork/Lidar-Index-Tiles-LINZ/"
                        
                        
                        lidar_tiles_dn = list.dirs(dn, recursive = F)
                        
                        for (i in 1:length(lidar_tiles_dn)){
                          
                          # i = 2
                          
                          cdir = lidar_tiles_dn[i]
                          fls = list.files(cdir, full.names = T)
                          
                          
                          ix = which(str_detect(fls, ".shp"))
                          cfile = fls[ix]
                          
                          SF = st_read(cfile)
                          
                          name_tileset = str_extract(basename(cfile),  ".+?(?=-lidar)")
                          print("************************************************************************************")
                          print(paste("No.", i, name_tileset))
                          print("************************************************************************************")
                          print(paste("No.", i, name_tileset))
                          SF_w_name = SF %>% mutate(name = name_tileset)
                          if (i==1){
                            SF_COL = SF_w_name
                          }else{
                            
                            SF_COL = SF_COL %>% bind_rows(SF_w_name)
                          }
                          
                          
                          
                          
                          
                          
                          
                          
                          
                          
                        }
                        
                        
                        NZ_LINZ_LIDAR_INDEX_TILES_ffn = paste0(dn, "All_LINZ_LiDAR_Index_Tiles.shp")
                        st_write(SF_COL, NZ_LINZ_LIDAR_INDEX_TILES_ffn, append = F)
                        
                        
                        
                        ```
                        
                        # Dissolve internal lines in LIDAR INDEX TILES just to get outline
                        
                        ```{r}
                        
                        NZ_LINZ_LIDAR_INDEX_TILES_ffn = paste0(dn, "All_LINZ_LiDAR_Index_Tiles.shp")
                        LIT = st_read(NZ_LINZ_LIDAR_INDEX_TILES_ffn)
                        
                        LIT_sel = LIT %>% filter(name=="otago")
                        
                        mapview(LIT_sel)
                        
                        
                        ```
                        
                        ```{r}
                        
                        franconia %>% 
                          group_by(district)
                        
                        mapview(franconia)
                        
                        franconia %>% 
                          group_by(district) %>%
                          st_union() %>%
                          mapview(zcol = "district")
                        
                        franconia %>% 
                          group_by(district) %>% 
                          summarise(m = mean(SHAPE_LEN)) %>% 
                          st_cast() %>% 
                          mapview(zcol = "m")
                        
                        ```
                        
                        